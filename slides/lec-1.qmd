---
title: "Introductie in R, Quarto en RStudio"
author: 
  - name: Gerko Vink
    orcid: 0000-0001-9767-1924
    email: g.vink@uu.nl
    affiliations:
      - name: Methodology & Statistics @ Utrecht University
date: 2 June 2025
date-format: "D MMM YYYY"
execute: 
  echo: true
format: 
  revealjs:
    theme: [solarized, gerko.scss]
    embed-resources: true
    progress: true
    margin: 0.075
    logo: logo.png 
    toc: false
    toc-depth: 1
    toc-title: Outline
    slide-number: true
    scrollable: true
    width: 1200
    reference-location: margin
    footer: Gerko Vink @ Anton de Kom Universiteit, Paramaribo
    standalone: true
---

## Disclaimer {.smaller}
I owe a debt of gratitude to many people as the thoughts and code in these slides are the process of years-long development cycles and discussions with my team, friends, colleagues and peers. When someone has contributed to the content of the slides, I have credited their authorship.

These materials are generated by Gerko Vink, who holds the copyright. The intellectual property belongs to Utrecht University. Images are either directly linked, or generated with StableDiffusion or DALL-E. That said, there is no information in this presentation that exceeds legal use of copyright materials in academic settings, or that should not be part of the public domain. 

::: {.callout-warning}
You **may use** any and all content in this presentation - including my name - and submit it as input to generative AI tools, with the following **exception**:

- You must ensure that the content is not used for further training of the model
:::

## RStudio

![](img/lec1/Rstudio.png){width="70%"}

## `RStudio` - Integrated Development Environment (IDE) for `R`

-   **RStudio** is a powerful integrated development environment (IDE) designed specifically for the R programming language.
-   It offers a user-friendly interface and a suite of tools to enhance your R coding experience.

### Key Features of RStudio

-   **1. Code Editing**: RStudio provides a code editor with syntax highlighting, autocompletion, and error checking, making your coding process more efficient.

-   **2. Console**: An interactive R console allows you to execute `R` code line by line and view results in real time.

-   **3. Environment Pane**: Keep track of your variables, data frames, and functions with the environment pane.

-   **4. Plots and Visualizations**: Create and view plots, charts, and visualizations within RStudio.

-   **5. Integrated Help**: Access `R` documentation, packages, and online resources directly from the IDE.

-   **6. Version Control**: Easily integrate `R` projects with version control systems like Git.

-   **7. Markdown Support**: RStudio seamlessly integrates with Markdown, making it an ideal choice for creating reproducible reports and documents.

It plays a crucial role in promoting reproducibility and collaboration in data science and statistical analysis.

## Some more detail about `RStudio`

**Integrated Development Environment (IDE)**

![](img/lec1/fig2.rstudio-editor.png){width=75%}

[Source figure: R for Data Science](https://r4ds.had.co.nz/introduction.html)

## Use `RStudio Projects`

Every time you start a new (data analysis) project, make it a habit to create a new `RStudio Project`.

**Because you want your project to work:**

-   not only now, but also in a few years;
-   when the folder and file paths have changed;
-   when collaborators want to run your code on their computer.

`RStudio Projects` create a convention that guarantees that the project
can be moved around on your computer or onto other computers and will
still "just work".

## Example data analysis project with `RStudio project`

![](img/lec1/Example-project-structure.png){width=75%}

Every time you want to work on this project: open the project by
clicking the `.Rproj` file.

## RMarkdown, GitHub-Flavored Markdown, and Quarto

-   **Markdown** is a lightweight markup language for creating formatted text using plain text. It's easy to learn and widely used in various applications.

-   **GitHub-Flavored Markdown (GFM)** is a variant of Markdown used on [GitHub](https://github.com) (next week), enhancing its capabilities for documentation and collaboration.

-   **RMarkdown** is an extension of Markdown that allows you to embed `R` code and its output directly within a document.

    -   Perfect for creating reproducible reports, research papers, and presentations.

-   **Quarto** is a comprehensive tool for creating reproducible and collaborative data science documents.

    -   Combines the power of Markdown, $\LaTeX$, and code execution to streamline document preparation.

## Popular Code Editors (for `R`)

-   **RStudio**: Ideal for R programming with features tailored for data analysis and visualization.
-   **Visual Studio Code (VS Code)**: A versatile code editor with a vast ecosystem of extensions for various languages.
-   **Eclipse (with StatET)**: Eclipse StatET is an integrated development environment (IDE) for R, offering features for R programming and data analysis.

### Popular Notebook Environments

-   **Jupyter Notebooks**: Widely used interactive kernel-based computing environment for data science and machine learning, supporting multiple (i.e. almost all) programming and scripting languages.

-   **RMarkdown**: An R-based notebook environment that combines code, output, and narrative text in a single document.

## Structure of a Quarto Document

-   A Quarto document is organized into **blocks**, which serve as the fundamental building blocks of the document's content.
-   Each block can contain a combination of the following elements:
    -   **Text**: Narrative content and explanations.
    -   **Code**: R code chunks for computations and data analysis.
    -   **Equations**: Mathematical equations and notation.
    -   **Figures**: Visualizations, charts, and images.
    -   **Tables**: Data tables for presenting results.
    -   **YAML Headers**: Metadata and document configuration.
    -   **Sections and Subsections**: Structuring the document into hierarchical sections for organization.

## Quarto: the YAML header

**YAML (YAML Ain't Markup Language)** is a human-readable data serialization format commonly used for configuration files and metadata in various programming and markup contexts.

-   YAML is very simple and readable

-   In `Quarto` and many other applications, YAML is used to specify:

    -   **Document Metadata**: Information about the document itself, such as the title, author, date, and document type.

    -   **Document Configuration**: Settings related to the document's behavior, appearance, and rendering, such as the output format (e.g., HTML, PDF), document template, and style options.

    -   **Custom Variables**: Definitions of custom variables or parameters that can be used throughout the document to control behavior or content.

Here's an example of a simple YAML header in a Quarto document:

``` yaml
---
title: "All flavors markdown"
author: 
  - name: Gerko Vink
    orcid: 0000-0001-9767-1924
    email: g.vink@uu.nl
    affiliations:
      - name: Methodology & Statistics @ UU University
  - name: Hanne Oberman
    orcid: 0000-0003-3276-2141
    email: h.i.oberman@uu.nl
    affiliations:
      - name: Methodology & Statistics @ UU
date: 25 Sep 2024
date-format: "D MMM YYYY"
bibliography: data/lec-2/publications.bib
execute: 
  echo: true
editor: source
format: 
  revealjs:
    embed-resources: true
    theme: [solarized, gerko.scss]
    progress: true
    multiplex: true
    transition: fade
    slide-number: true
    margin: 0.075
    logo: "images/logo.png" 
    toc: false
    toc-depth: 1
    toc-title: Outline
    scrollable: true
    reference-location: margin
    footer: Gerko Vink and Hanne Oberman - Markup Languages @ UU
---
```

In this example:

-   `title`, `author`, and `date` provide metadata about the document.
-   `output` specifies settings related to the document's output format and theme.

The YAML header is a powerful tool for customizing and configuring Quarto documents, allowing you to control how the document is rendered and presented. It ensures that important document information and settings are stored in a human-readable and structured format at the beginning of the document.

## Text in `Quarto`

Text is text. Nothing more, nothing less

### Header

#### Subheader

##### Subsubheader

``` markdown
# This is a heading indicating a section
## This is a heading indicating a subsection
### This is a heading indicating a subsubsection
```

But in the above I used

``` markdown
### Header
#### Subheader
##### Subsubheader
```
<br>

Why?

# A single # denotes a section in slides

## A double ## denotes a slide
It is that simple. No more framing in $\LaTeX$ or other stuff. Just use the `#` and `##` to denote a section and a slide.

## Disclaimer

I owe a debt of gratitude to many people as the thoughts and code in these slides are the process of years-long development cycles and discussions with my team, friends, colleagues and peers. When someone has contributed to the content of the slides, I have credited their authorship.

Scientific references are in the footer. Opinions and figures are my own, AI-generated or directly linked.

::: callout-tip
# Materials
- course page [www.gerkovink.com/sur](https://www.gerkovink.com/sur)
- source: [github.com/gerkovink/sur](https://github.com/gerkovink/sur)
:::

# Programming

## Goal 1: Learn to program in R

![](img/lec1/state_programming.png) 

## 2. Goal 2: Learn statistical programming

What is statistical programming?

Broadly speaking:

-   **Computer programming** is more focused on software development.

-   **Statistical programming** is more focused on data analysis and the
    communication of the results.

In this course we focus more on the HOW of doing data analysis in R. It is not primarily a course in statistics.

![](img/lec1/fig0_stat_programming.png){width=80%}

[Source figure: R for Data
Science](https://r4ds.had.co.nz/introduction.html)

## Goal 3: Learn to program together

The most important skill for a programmer that creates usable code is that other people can use it, develop it further and understand it.

# Practical 1

## So far

So far, we have learned the basics of programming in `R`:

- assign elements to objects with `<-` (alt/option -)
- work with `RStudio` and `R Markdown`
- run code
- organize your work with projects in `RStudio`

```{r echo=FALSE}
set.seed(123)
```

## Topics

* R packages
* Getting help
* Functions
* R objects and data types
* Data manipulation: subsetting and logical operators


# R Packages

## R Packages: base installation

* When you start `RStudio` and `R` only the base packages are activated: the basic installation with basic functionality.
* There are almost 20.000 packages that have been developed by R users all over the world. See the [Comprehensive R Archive Network (CRAN)](https://cran.r-project.org/web/packages/)
* Not efficient to have all these packages installed every time you use R. Install only the packages you want to use.

Use `sessionInfo()` to see which packages are active. This is how the basic installation looks like:

![](img/lec1/BaseInstallationR.png){width=80%}

## How to work with packages

Packages are like apps on your mobile phone.

* When you want to use a package for the first time, you have to install the package.
* Each time you want to use the package, you have to load (activate) it.

## Installing packages

The easiest way to install a package, e.g. mice, is to use:
```{r eval=FALSE}
install.packages("mice")
```

Alternatively, you can also do it in `RStudio` through:

`Tools -> Install Packages`

An overview of the packages you have installed, see the tab “Packages” in the output pane:

![](img/lec1/InstalledPackageOverview.png){width=80%}

## Loading packages

There are two ways to load a package in `R`:
```{r eval=FALSE}
library(mice)
```

and

```{r eval=FALSE}
require(mice)
```

When a package is not found (not installed):

* `require()` will produce a warning but will continue to run the rest of the code.
* `library()` will produce an error and stop running the rest of the code.

# Getting help

## Getting help when you know the function or package

Everything that is published on the Comprehensive `R` Archive Network (CRAN) and is aimed at `R` users, must be accompanied by a help file.

*In the search bar of the output pane:*

* type name of the function or package

*In the console:*

* type `help(sample)` or `?sample` (opens a help window).
* type `help(package=mice)` for packages
* when you start typing `sample` in console or editor (Markdown code chunk) a pop-up window appears with help about the structure of the function.

![](img/lec1/Help-pop-up.png){width=80%}


## Getting help when you do not know the function or package

* Type your search term in the search bar of the output pane.

* In the console:
    + Type `??` followed by your search term.
    + For example `??anova` returns a list of all help pages that contain the word ‘anova’.

* Some packages have cheat sheets, see in `R Studio`, `Help menu -> Cheat Sheets`

* Google the search term(s) and add ‘R’ as keyword.

* Helpful websites: <http://www.stackoverflow.com> and <http://www.stackexchange.com>


# Functions

## Functions in R

* Functions are the building blocks of `R`

* Built-in or user-defined (programme your own functions).

* To use a function, type the function name with parentheses: `mean()`

* Typing the name of the function without the parentheses reveals the code of the function.

![](img/lec1/syntax-function-sample.png){width=80%}


## The structure of functions in R

Every function in R has the following structure:

![](img/lec1/Elements-of-a-function_HandsonProgrammingWithR_2.6.png){width=80%}


<sup>
[Image source: Garrett Grolemund, Hands-On Programming with R, 2.6](https://rstudio-education.github.io/hopr/basics.html#functions)
</sup>


## Using R functions: arguments

When you want to use a function in R, you need to know which information you need to provide to the function. 

For example the function `sample()`

Use `args(<function name>)` to obtain info about the arguments and the default values: 

```{r}
args(sample)
```


Or make use of the pop-up help and use the TAB key to cycle through the arguments:

![](img/lec1/Help-pop-up.png){width=80%}


## Using R functions: help file

Clicking `F1` opens the help file of the function `sample()`:

![](img/lec1/R-Helpfile-function-sample.png){width=80%}


## Using R funtions: arguments

Now we can use the function to, for example, mimic the sampling of two dice.

```{r}
dice <- sample(1:6, size=2, replace=TRUE)
dice
```

`x` represents the items to sample from (the range of possible items). In this case the numbers 1 to 6 (the eyes of single die).

`size` is the number of items to choose, in this case 2

`replace=TRUE` means sampling with replacement

![](img/lec1/dice){width=35%}


## Using function arguments

Will the function work if we leave out the argument names and give only the values?

```{r}
dice <- sample(1:6, 2, TRUE)
dice
```

And if we change the order of the values?
```{r error=TRUE}
dice <- sample(2, 1:6, TRUE)
dice
```
## Using function arguments

Changing the order is possible only when the argument is mentioned. 
```{r}
dice <- sample(size=2, x=1:6, replace=TRUE)
dice
```
**Recommendation: type out the arguments and their values. This prevents errors and increases the readability of your code.**


# R objects and data types

## Vector: most basic R object

A vector is an indexed set of values (a list of numbers) and has one dimension (row vector or column vector). The simplest vector has 1 element. 

`c()` creates a list of numbers:

```{r}
v1 <- c(3)
v1
v2 <- c(1:12)
v2
```

Vectors can have the following data atomic modes: *integer, numeric/double, character, logical, complex*

## Most often used data types

**Numeric (double):**
```{r}
v3 <- c(100:110)
v3
```

**Integer:**
```{r}
v4 <- c(1L:12L)
v4
```
## Most often used data types

**Character:**
```{r}
v5 <- c(letters[21:26])
v5
names <- c("Mike", "Anne", "George")
names
```

**Logical:**
```{r}
v6 <- c(TRUE, FALSE)
v6
```

## Create vectors

With `c()` 
```{r}
vector <- c(25:30)
vector
```
Simple replication with `rep()`
```{r}
rep(1:2, 3)
```
## Create vectors

Or more complex:
```{r}
rep(c("A", "B"), c(2, 3))
rep(c("A", "B"), each=3)
```
Sequence of numbers with `seq()`
```{r}
seq(from=2, to=10, by=2)
```

## Matrices
`matrix()` creates arrays with specified dimensions, e.g. vectors:
```{r}
rvect <- matrix(data=vector, nrow=6, ncol=1)
rvect
dim(rvect)
```



## Matrices

A matrix:
```{r}
(M1 <- matrix(v2, nrow=3, ncol=4))
dim(M1)
(M2 <- matrix(v2, nrow=4, ncol=3))
```

## Vectors and matrices: limitation

Vectors and matrices can only hold one data type. Remember, matrices and vectors are numerical OR character objects. They can never contain both and still be used for numerical calculations. 
```{r}
vector
v5
(newvect <- c(vector, v5))
```
## Vectors and matrices: limitation

Vectors and matrices can only hold one data type
```{r}
vector
v5
M <- matrix(cbind(vector, v5), nrow=6, ncol=2)
M
```


## Lists

Lists are flexible data structures: the elements in a list may be a combination of different data types (numeric, character) and dimensions.


```{r}
L <- list(names, vector, M)
L
```
## Assigning names to elements

Assign names to the elements of a list with `names()`. Notice the `$`.

```{r}
names(L) <-c("Names", "Numbers", "Matrix")
L
```
## Data frames

A data frame is the `R` representation of a rectangular data set where the rows are the observations and the columns the variables.

Data frames can contain both numerical and character column vectors at the same time, although never in the same column. 
```{r}
D <- data.frame("V1" = rnorm(5),
                "V2" = rnorm(5, mean = 5, sd = 2), 
                "V3" = letters[1:5])
D
```

We 'filled' a data frame with two randomly generated sets from the normal distribution - where $V1$ is standard normal and $V2 \sim N(5,2)$ - and a character set. 

## Data frames (continued)
You can name the columns and rows in data frames with `row.names`:
```{r}
row.names(D) <- c("row 1", "row 2", "row 3", "row 4", "row 5")
D
```


## Factors

* Factors are used to represent categorical data (ordered or unordered).

* A factor is a vector with integers where each integer has a label.

* Factors facilitate interpretation of results in statistical modeling: a variable with labels "male", "female" is self-describing compared to a variable with values `1`, `2`.

* Factors are very useful in statistical modeling (linear models, GLM) where they facilitate the dummy coding process of categorical variables.

## Factors

Factor objects can be created with the `factor()` function.
```{r}
x <- factor(c("male", "male", "female", "male", "female"))
x
```

Obtain the `summary` of the factor:
```{r}
summary(x)
```

## Factors 
Factors are integer vectors where each integer has a label (`levels`):
```{r}
typeof(x)
```

```{r}
attributes(x)
```

# Data manipulation: subsetting and logical operators

## Subsetting
In the basic installation of R ("base R") there are three ways to select elements from vectors, matrices, lists and data frames: 

1) **`[]`**

2) **`[[]]`**

3) **`$`**


## Subsetting with `[]`

Square brackets `[]` are used to call single elements or entire rows and columns.

`[a, b]`: **a** refers to the row number(s), **b** refers to the column number(s).

```{r}
M <- matrix(rnorm(12), nrow=3, ncol=4)
M
M[2, 3]
```

## Subsetting with `[]`

Also for data frames:

```{r}
D
D[2, 3] # Select element "b"
```
## Subsetting with `[]`

```{r}
D
D[2, ] # Select second row
D[, 1] # Select first column
```

## Subsetting with `[]`

```{r}
D
D[2:3, 2] # Select second and third row in second colum
D[1, c(2,3)] # Select elements in the first row, second and third column
```


## Subsetting with `[]`

```{r}
D
D[ , -3] # Select all rows and leave out the third column.
```

## Subsetting with `[]`

```{r}
D
D[2:3, -c(3)] # Select the second and third row minus the third column
```


## Subsetting with `[[]]`

The `[[]]` operator selects only one element

```{r}
L
L[[1]]
```

## Subsetting with `$`

Use `$` to select elements with name labels in lists or data frames:


```{r echo=FALSE}
L
```

```{r}
L$Names
```

## Subsetting with `$`

Use `$` to select a variable in a data frame:

```{r echo=FALSE}
D
```

```{r}
D$V3
```

## Logical operators
Logical operators are signs that evaluate a statement, such as `==`, `<`, `>`, `<=`, `>=`, and `|` (OR) as well as `&` (AND). Typing `!` before a logical operator takes the complement of that action. 

For example, if we would like to select elements of vector `v` that are larger than 6, we would type:
```{r }
v <- c(1:12)
v

v[v > 6]
```

## Why does a logical statement on a matrix return a vector?

```{r }
v
v > 6
```

The column values for `TRUE` may be of different length. A vector as a return is therefore more appropriate. The `TRUE` and `FALSE` values serve as indicators to select the elements in `v` larger than 6.
```{r}
v[v > 6]
```


## Logical operators

Symbol | Meaning
------ | ------
! | logical *not*
$\&$ | logical *and*
$|$ | logical *or* 
$<$ | less than
$<=$ | less than or equal to 
$>$ | greater than
$>=$ | greater than or equal to
$==$ | logical equals
$!=$ | not equal

## Integers and floating points
In R there are two types of numbers: integers and [floating point numbers](https://floating-point-gui.de/formats/fp/). Since computer memory is limited, you cannot store numbers with infinite precision. Numbers are therefore represented with floating point numbers. Floating points cannot represent decimal fractions exactly in most cases.
```{r}
(3 - 2.9)
(3 - 2.9) <= 0.1
```
Why does R tell us that `3 - 2.9 ≠ 0.1?`
```{r}
(3 - 2.9) - 0.1
```
## Floating point representation
Let's have a look at how the decimal fractions are actually represented as floating points. You can see this by asking a representation with 54 decimals.

```{r}
sprintf("%.54f",3 - 2.9)

sprintf("%.54f",0.1)

```

## How to work with floating points
The difference of 8.326673e-17 is smaller than the representable difference between two numbers whose value is close to 0.1. 

The smallest positive floating point number in R is: 2.220446e-16

```{r}
(3 - 2.9) - 0.1

 .Machine$double.eps
```

## How to work with floating points
You can verify whether the difference between two floating points is smaller than the smallest positive floating point number (2.220446e-16). 

Or use the `all.equal()` function which checks that the difference is close to the smallest floating point number.

```{r}
((3 - 2.9) - 0.1) < .Machine$double.eps

all.equal((3 - 2.9), 0.1)

```

# Practical 2